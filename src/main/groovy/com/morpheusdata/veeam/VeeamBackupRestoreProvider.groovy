package com.morpheusdata.veeam

import com.morpheusdata.core.MorpheusContext
import com.morpheusdata.core.Plugin
import com.morpheusdata.core.backup.BackupRestoreProvider
import com.morpheusdata.core.backup.response.BackupRestoreResponse
import com.morpheusdata.core.data.DataFilter
import com.morpheusdata.core.data.DataQuery
import com.morpheusdata.core.util.DateUtility
import com.morpheusdata.model.BackupProvider
import com.morpheusdata.model.Cloud
import com.morpheusdata.model.ComputeServer
import com.morpheusdata.model.Workload
import com.morpheusdata.response.ServiceResponse;
import com.morpheusdata.model.BackupRestore;
import com.morpheusdata.model.BackupResult;
import com.morpheusdata.model.Backup;
import com.morpheusdata.model.Instance
import com.morpheusdata.veeam.services.ApiService
import com.morpheusdata.veeam.utils.VeeamUtils
import groovy.util.logging.Slf4j

import static com.morpheusdata.veeam.VeeamBackupRestoreProvider.*

@Slf4j
class VeeamBackupRestoreProvider implements BackupRestoreProvider {

	Plugin plugin
	MorpheusContext morpheus
	ApiService apiService

	VeeamBackupRestoreProvider(Plugin plugin, MorpheusContext morpheusContext) {
		this.plugin = plugin
		this.morpheus = morpheusContext
		this.apiService = new ApiService()
	}

	/**
	 * Add additional configurations to a backup restore. Morpheus will handle all basic configuration details, this is a
	 * convenient way to add additional configuration details specific to this backup restore provider.
	 * @param backupResultModel backup result to be restored
	 * @param config the configuration supplied by external inputs
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse configureRestoreBackup(BackupResult backupResult, Map config, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Build the configuration for the restored instance.
	 * @param backupResultModel backup result to be restored
	 * @param instanceModel the instance the backup was created from, if it still exists. Retained backups will not have a reference to the instance.
	 * @param restoreConfig the restore configuration generated by morpheus.
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getBackupRestoreInstanceConfig(BackupResult backupResult, Instance instanceModel, Map restoreConfig, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Verify the backup restore is valid. Generally used to check if the backup and instance are both in a state
	 * compatible for executing the restore process.
	 * @param backupResultModel backup result to be restored
	 * @param opts optional parameters used for configuration.
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse validateRestoreBackup(BackupResult backupResult, Map opts) {
		return ServiceResponse.success()
	}

	/**
	 * Get restore options to configure the restore wizard. Although the {@link com.morpheusdata.core.backup.BackupProvider } and
	 * {@link com.morpheusdata.core.backup.BackupTypeProvider} supply configuration, there may be situations where the instance
	 * configuration will determine which options need to be presented in the restore wizard.
	 * <p>
	 * Available Restore options:
	 * 		<ul>
	 * 		 	<li>
	 * 		 	    restoreExistingEnabled (Boolean) -- determines the visibility of the restore to existing option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	restoreNewEnabled (Boolean) -- determines the visibility of the restore to new option
	 * 		 	</li>
	 * 		 	<li>
	 * 		 	  	name (String) -- default name of the restored instance
	 * 		 	</li>
	 * 		 	<li>
	 * 		 		hostname (String) -- default hostname of the restored instance
	 * 		 	</li>
	 * 		</ul>
	 *
	 * @param backupModel the backup
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse getRestoreOptions(Backup backup, Map opts) {
		log.debug "getRestoreOptions: backup: ${backup}, opts: ${opts}"
		ServiceResponse rtn = ServiceResponse.prepare()

		//If the backup has infrastructure config save, but the hostname no longer exists in cloud then we need to create a new VM.
		//If the hostname still exists in the cloud then we can restore to the existing VM.
		def restoreOptions = [restoreExistingEnabled:true]
		Workload workload = morpheus.services.workload.get(backup.containerId)
		//if original workload still exists, restore to that
		if(workload) {
			restoreOptions.restoreExistingEnabled = true
			restoreOptions.hostname = workload.server?.hostname
		} else {
			def infrastructureConfig = backup.getConfigProperty('infrastructureConfig')
			if(infrastructureConfig) {
				//original workload was removed and backup was preserved
				def name = infrastructureConfig.server?.displayName
				Cloud cloud = morpheus.services.cloud.get(infrastructureConfig.server?.zoneId)
				def serverResults = []
				morpheus.services.computeServer.list(new DataQuery().withFilters(
						new DataFilter<>('zone.id', cloud.id),
						new DataFilter<>('name', name)
				)).each { ComputeServer server ->
					if(server.externalId != null) {
						serverResults << server
					}
				}
				def server = serverResults.size() == 1 ? serverResults.getAt(0) : null

				//if there is a server with the same name in the same cloud, it was already re-created so restore there
				if(server) {
					restoreOptions.name = name
					Workload restoreWorkload = morpheus.services.workload.find(new DataQuery().withFilter('server.id', server.id))
					if(restoreWorkload) {
						restoreOptions.restoreExistingEnabled = true
						restoreOptions.restoreContainerId = restoreWorkload?.id
					} else {
						// only a portion of the infrastructure remains, probably an incomplete
						// delete of the source instance, force a new restore.
						restoreOptions.restoreNewEnabled = true
						restoreOptions.restoreExistingEnabled = false
					}
				} else {
					restoreOptions.restoreNewEnabled = true
					restoreOptions.restoreExistingEnabled = false
				}
			}
		}
		rtn.data = restoreOptions
		rtn.success = true
		return rtn
	}

	/**
	 * Execute the backup restore on the external system
	 * @param backupRestoreModel restore to be executed
	 * @param backupResultModel refernce to the backup result
	 * @param backupModel reference to the backup associated with the backup result
	 * @param opts optional parameters
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse restoreBackup(BackupRestore backupRestore, BackupResult backupResult, Backup backup, Map opts) {
		log.debug("restoreBackup, restore: {}, source: {}, opts: {}", backupRestore, backupResult, opts)
		ServiceResponse rtn = ServiceResponse.prepare(new BackupRestoreResponse(backupRestore))
		def backupSessionId = backupResult.externalId ?: backupResult.getConfigProperty('backupSessionId')
		log.info("Restoring backupResult {} - opts: {}", backupResult, opts)
		try {
			def containerId = opts.containerId ?: backup?.containerId
			Workload workload = containerId ? morpheus.services.workload.get(containerId) : null
			ComputeServer server = workload?.server?.id ? morpheus.services.computeServer.get(workload.server.id) : null
			Cloud cloud = server.cloud.id ? morpheus.services.cloud.get(server.cloud.id) : null
			def objectRef = VeeamUtils.getVmHierarchyObjRef(backup, server)
			def authConfig = apiService.getAuthConfig(backup.backupProvider)
			def tokenResults = apiService.getToken(authConfig)
			def token = tokenResults.token
			def sessionId = tokenResults.sessionId
			def infrastructureConfig = backupResult.getConfigProperty('infrastructureConfig') ?: backup.getConfigProperty('infrastructureConfig')


			def restoreOpts = [authConfig: authConfig, cloudTypeCode: cloud?.cloudType?.code, backupType: backupResult.backupType]
			if(backupResult.getConfigProperty("restoreHref")) {
				restoreOpts += backupResult.getConfigMap()
			} else {
				restoreOpts.restorePointRef = backupResult.getConfigProperty('restorePointRef') ?: backupResult.getConfigProperty('vmRestorePointRef')
				if(backupResult.getConfigProperty('restorePointRef')) {
					restoreOpts.restorePointId = VeeamUtils.extractVeeamUuid(backupResult.getConfigProperty('restorePointRef'))
				}
				if(backupResult.getConfigProperty('vmRestorePointRef')) {
					restoreOpts.vmRestorePointid = VeeamUtils.extractVeeamUuid(backupResult.getConfigProperty('vmRestorePointRef'))
				}
			}
			restoreOpts.hierarchyRoot = backup.getConfigProperty('hierarchyRoot')
			restoreOpts.containerId = containerId
			restoreOpts.vmId = server.externalId
			restoreOpts.vmName = server.displayName
			if(restoreOpts.cloudTypeCode == 'vcd') {
				restoreOpts.vdcId = cloud.getConfigProperty("vdcId")
				restoreOpts.vAppId = server.internalId?.toLowerCase()?.replace("vapp-", "")
				restoreOpts.vCenterVmId = server.uniqueId
				objectRef = objectRef.replace("vapp-", "").replace("vm-", "")
			}
			log.debug("restoreBackup:[apiUrl: {}, vmId: {}, backupSessionId: {}, opts: {}", authConfig.apiUrl, objectRef, backupSessionId, restoreOpts)
			def restoreResults = apiService.restoreVM(authConfig.apiUrl, token, objectRef, backupSessionId, restoreOpts)
			log.debug("restoreBackup result: {}", restoreResults)
			if(restoreResults.success) {
				//update instance status to restoring
				if(workload.instance?.id) {
					def instance = morpheus.services.instance.get(workload.instance.id)
					if(instance) {
						instance.status = Instance.Status.restoring.toString()
						morpheus.services.instance.save(instance)
					}
				}
				server.internalName = infrastructureConfig?.server?.name
				morpheus.services.computeServer.save(server)

				backupRestore.status = 'IN_PROGRESS'
				backupRestore.externalStatusRef = restoreResults.restoreSessionId
				backupRestore.containerId = workload.id
				rtn.success = true
			} else {
				backupRestore.status = 'FAILED'
				backupRestore.errorMessage = restoreResults.msg

				if(workload.instance?.id) {
					def instance = morpheus.services.instance.get(workload.instance.id)
					if(instance) {
						instance.status = Instance.Status.failed.toString()
						morpheus.services.instance.save(instance)
					}
				}
			}
			apiService.logoutSession(authConfig.apiUrl, token, sessionId)
		} catch(e) {
			log.error("restoreBackup error", e)
			rtn.error = "Failed to restore Veeam backup: ${e}"
		}
		return rtn
	}

	/**
	 * Periodically check for any updates to an in-progress restore. This method will be executed every 60 seconds for
	 * the restore while the restore has a status of `START_REQUESTED` or `IN_PROGRESS`. Any other status will indicate
	 * the restore has completed and does not need to be refreshed. The primary use case for this method is long-running
	 * restores to avoid consuming resources during the restore process.
	 * @param backupRestore the running restore
	 * @param backupResult backup result referencing the backup to be restored
	 * @return a {@link ServiceResponse} object. A ServiceResponse with a false success will indicate a failed
	 * configuration and will halt the backup restore process.
	 */
	@Override
	ServiceResponse refreshBackupRestoreResult(BackupRestore backupRestore, BackupResult backupResult) {
		log.debug "refreshBackupRestoreResult: ${backupRestore}, ${backupResult}"

		ServiceResponse<BackupRestoreResponse> rtn = ServiceResponse.prepare(new BackupRestoreResponse(backupRestore))
		Backup backup = morpheus.services.backup.get(backupResult.backup.id)
		BackupProvider backupProvider = backup.backupProvider
		if(!backupProvider.enabled) {
			rtn.msg = "Veeam not enabled"
			return rtn
		}

		try{
			def apiUrl = apiService.getApiUrl(backupProvider)
			def session = apiService.loginSession(backupProvider)
			def token = session.token
			def sessionId = session.sessionId
			def restoreSessionId = backupRestore.externalStatusRef
			def result = apiService.getRestoreResult(apiUrl, token, restoreSessionId)
			def restoreSession = result.result
			apiService.logoutSession(apiUrl, token, sessionId)

			log.debug "restoreSession: ${restoreSession}"
			if(restoreSession) {
				//update the restore with what we got back from veeam
				rtn.data.backupRestore.externalStatusRef = restoreSession.restoreSessionId
				rtn.data.backupRestore.externalId = restoreSession.vmId
				rtn.data.backupRestore.status = VeeamUtils.getBackupStatus(restoreSession.result)
				def startDate = restoreSession.startTime
				def endDate = restoreSession.endTime
				if(startDate && endDate) {
					def start = DateUtility.parseDate(startDate)
					def end = DateUtility.parseDate(endDate)
					rtn.data.backupRestore.startDate = start
					if(rtn.data.backupRestore.status == BackupResult.Status.SUCCEEDED.toString() || rtn.data.backupRestore.status == BackupResult.Status.FAILED.toString()) {
						rtn.data.backupRestore.endDate = end
					}
					rtn.data.backupRestore.lastUpdated = new Date()
					rtn.data.backupRestore.duration = (start && end) ? (end.time - start.time) : 0
					rtn.data.updates = true
				}

				if(rtn.data.backupRestore.status == BackupResult.Status.SUCCEEDED.toString() && rtn.data.backupRestore.externalId) {
					finalizeRestore(rtn.data.backupRestore)
				}
			}
		} catch(Exception ex) {
			log.error("syncBackupRestoreResult error", ex)
		}
	}

	ServiceResponse finalizeRestore(BackupRestore restore) {
		log.info("finalizeRestore: {}", restore)
		def instance
		try {
			// Need to update the externalId as it has changed
			def targetWorkload = morpheus.services.workload.get(restore.containerId)
			def server = targetWorkload?.server

			morpheus.async.backup.backupRestore.finalizeRestore(targetWorkload)

			// do we still need this with finalizeRestore above?
			// if(server?.zone?.zoneType?.code == 'vmware' && server?.serverOs?.vendor == 'centos') {
			// 	log.debug("Finalizing restore: renew IP for CentOS VM.")
			// 	morpheus.executeCommandOnServer(server, "dhclient", null, null, null, null, null, null, null, true, true)
			// }
		} catch(e) {
			log.error("Error in finalizeRestore: ${e}", e)
			instance?.status = Instance.Status.failed
			instance?.save(flush:true)
		}

		return ServiceResponse.success()
	}
}
